package crypto

import (
	"context"
	"crypto/aes"
	"crypto/cipher"
	"crypto/hmac"
	"crypto/rand"
	"crypto/sha256"
	"encoding/base64"
	"encoding/hex"
	"errors"
	"fmt"
	"io"

	libLog "github.com/LerianStudio/lib-uncommons/v2/uncommons/log"
)

var (
	// ErrCipherNotInitialized is returned when encryption/decryption is attempted before InitializeCipher.
	ErrCipherNotInitialized = errors.New("cipher not initialized")
	// ErrCiphertextTooShort is returned when the ciphertext is shorter than the nonce size.
	ErrCiphertextTooShort = errors.New("ciphertext too short")
	// ErrNilCrypto is returned when a Crypto method is called on a nil receiver.
	ErrNilCrypto = errors.New("crypto instance is nil")
)

// Crypto groups hashing and symmetric encryption helpers.
type Crypto struct {
	HashSecretKey    string
	EncryptSecretKey string
	Logger           libLog.Logger
	Cipher           cipher.AEAD
}

// String implements fmt.Stringer to prevent accidental secret key exposure in logs or spans.
func (c *Crypto) String() string {
	if c == nil {
		return "<nil>"
	}

	return "Crypto{keys:REDACTED}"
}

// GoString implements fmt.GoStringer to prevent accidental secret key exposure in %#v formatting.
func (c *Crypto) GoString() string {
	return c.String()
}

// logger returns the configured Logger, falling back to a NopLogger if nil.
func (c *Crypto) logger() libLog.Logger {
	if c == nil || c.Logger == nil {
		return libLog.NewNop()
	}

	return c.Logger
}

// GenerateHash using HMAC-SHA256
func (c *Crypto) GenerateHash(plaintext *string) string {
	if c == nil || plaintext == nil {
		return ""
	}

	h := hmac.New(sha256.New, []byte(c.HashSecretKey))
	h.Write([]byte(*plaintext))

	hash := hex.EncodeToString(h.Sum(nil))

	return hash
}

// InitializeCipher loads an AES-GCM block cipher for encryption/decryption
func (c *Crypto) InitializeCipher() error {
	if c == nil {
		return ErrNilCrypto
	}

	if c.Cipher != nil {
		c.logger().Log(context.Background(), libLog.LevelInfo, "Cipher already initialized")
		return nil
	}

	decodedKey, err := hex.DecodeString(c.EncryptSecretKey)
	if err != nil {
		c.logger().Log(context.Background(), libLog.LevelError, "Failed to decode hex private key", libLog.Err(err))
		return fmt.Errorf("crypto: hex decode key: %w", err)
	}

	blockCipher, err := aes.NewCipher(decodedKey)
	if err != nil {
		c.logger().Log(context.Background(), libLog.LevelError, "Error creating AES block cipher with the private key", libLog.Err(err))
		return fmt.Errorf("crypto: create AES block cipher: %w", err)
	}

	aesGcm, err := cipher.NewGCM(blockCipher)
	if err != nil {
		c.logger().Log(context.Background(), libLog.LevelError, "Error creating GCM cipher", libLog.Err(err))
		return fmt.Errorf("crypto: create GCM cipher: %w", err)
	}

	c.Cipher = aesGcm

	return nil
}

// Encrypt a plaintext using AES-GCM, which requires a private 32 bytes key and a random 12 bytes nonce.
// It generates a base64 string with the encoded ciphertext.
func (c *Crypto) Encrypt(plainText *string) (*string, error) {
	if c == nil {
		return nil, ErrNilCrypto
	}

	if plainText == nil {
		return nil, nil
	}

	if c.Cipher == nil {
		return nil, ErrCipherNotInitialized
	}

	// Generates random nonce with a size of 12 bytes
	nonce := make([]byte, c.Cipher.NonceSize())
	if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
		c.logger().Log(context.Background(), libLog.LevelError, "Failed to generate nonce", libLog.Err(err))
		return nil, fmt.Errorf("crypto: generate nonce: %w", err)
	}

	// Cipher Text prefixed with the random Nonce
	cipherText := c.Cipher.Seal(nonce, nonce, []byte(*plainText), nil)

	result := base64.StdEncoding.EncodeToString(cipherText)

	return &result, nil
}

// Decrypt a base64 encoded encrypted plaintext.
// The encrypted plain text must be prefixed with the random nonce used for encryption.
func (c *Crypto) Decrypt(encryptedText *string) (*string, error) {
	if c == nil {
		return nil, ErrNilCrypto
	}

	if encryptedText == nil {
		return nil, nil
	}

	if c.Cipher == nil {
		return nil, ErrCipherNotInitialized
	}

	decodedEncryptedText, err := base64.StdEncoding.DecodeString(*encryptedText)
	if err != nil {
		c.logger().Log(context.Background(), libLog.LevelError, "Failed to decode encrypted text", libLog.Err(err))
		return nil, fmt.Errorf("crypto: decode base64: %w", err)
	}

	nonceSize := c.Cipher.NonceSize()
	if len(decodedEncryptedText) < nonceSize {
		c.logger().Log(context.Background(), libLog.LevelError, "Failed to decrypt ciphertext", libLog.Err(ErrCiphertextTooShort))

		return nil, ErrCiphertextTooShort
	}

	// Separating nonce from ciphertext before decrypting
	nonce, cipherText := decodedEncryptedText[:nonceSize], decodedEncryptedText[nonceSize:]

	// #nosec G407: Nonce is randomly generated by the Encrypt method
	// False positive described at https://github.com/securego/gosec/issues/1209
	plainText, err := c.Cipher.Open(nil, nonce, cipherText, nil)
	if err != nil {
		c.logger().Log(context.Background(), libLog.LevelError, "Failed to decrypt ciphertext", libLog.Err(err))
		return nil, fmt.Errorf("crypto: decrypt: %w", err)
	}

	result := string(plainText)

	return &result, nil
}
