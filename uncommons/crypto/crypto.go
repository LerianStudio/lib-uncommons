package crypto

import (
	"context"
	"crypto/aes"
	"crypto/cipher"
	"crypto/hmac"
	"crypto/rand"
	"crypto/sha256"
	"encoding/base64"
	"encoding/hex"
	"errors"
	"io"

	libLog "github.com/LerianStudio/lib-uncommons/uncommons/log"
)

// Crypto groups hashing and symmetric encryption helpers.
type Crypto struct {
	HashSecretKey    string
	EncryptSecretKey string
	Logger           libLog.Logger
	Cipher           cipher.AEAD
}

// logger returns the configured Logger, falling back to a NopLogger if nil.
func (c *Crypto) logger() libLog.Logger {
	if c.Logger != nil {
		return c.Logger
	}

	return libLog.NewNop()
}

// GenerateHash using HMAC-SHA256
func (c *Crypto) GenerateHash(plaintext *string) string {
	if plaintext == nil {
		return ""
	}

	h := hmac.New(sha256.New, []byte(c.HashSecretKey))
	h.Write([]byte(*plaintext))

	hash := hex.EncodeToString(h.Sum(nil))

	return hash
}

// InitializeCipher loads an AES-GCM block cipher for encryption/decryption
func (c *Crypto) InitializeCipher() error {
	if c.Cipher != nil {
		c.logger().Log(context.Background(), libLog.LevelInfo, "Cipher already initialized")
		return nil
	}

	decodedKey, err := hex.DecodeString(c.EncryptSecretKey)
	if err != nil {
		c.logger().Log(context.Background(), libLog.LevelError, "Failed to decode hex private key", libLog.Err(err))
		return err
	}

	blockCipher, err := aes.NewCipher(decodedKey)
	if err != nil {
		c.logger().Log(context.Background(), libLog.LevelError, "Error creating AES block cipher with the private key", libLog.Err(err))
		return err
	}

	aesGcm, err := cipher.NewGCM(blockCipher)
	if err != nil {
		c.logger().Log(context.Background(), libLog.LevelError, "Error creating GCM cipher", libLog.Err(err))
		return err
	}

	c.Cipher = aesGcm

	return nil
}

// Encrypt a plaintext using AES-GCM, which requires a private 32 bytes key and a random 12 bytes nonce.
// It generates a base64 string with the encoded ciphertext.
func (c *Crypto) Encrypt(plainText *string) (*string, error) {
	if plainText == nil {
		return nil, nil
	}

	if c.Cipher == nil {
		return nil, errors.New("cipher not initialized")
	}

	// Generates random nonce with a size of 12 bytes
	nonce := make([]byte, c.Cipher.NonceSize())
	if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
		c.logger().Log(context.Background(), libLog.LevelError, "Failed to generate nonce", libLog.Err(err))
		return nil, err
	}

	// Cipher Text prefixed with the random Nonce
	cipherText := c.Cipher.Seal(nonce, nonce, []byte(*plainText), nil)

	result := base64.StdEncoding.EncodeToString(cipherText)

	return &result, nil
}

// Decrypt a base64 encoded encrypted plaintext.
// The encrypted plain text must be prefixed with the random nonce used for encryption.
func (c *Crypto) Decrypt(encryptedText *string) (*string, error) {
	if encryptedText == nil {
		return nil, nil
	}

	if c.Cipher == nil {
		return nil, errors.New("cipher not initialized")
	}

	decodedEncryptedText, err := base64.StdEncoding.DecodeString(*encryptedText)
	if err != nil {
		c.logger().Log(context.Background(), libLog.LevelError, "Failed to decode encrypted text", libLog.Err(err))
		return nil, err
	}

	nonceSize := c.Cipher.NonceSize()
	if len(decodedEncryptedText) < nonceSize {
		err := errors.New("ciphertext too short")
		c.logger().Log(context.Background(), libLog.LevelError, "Failed to decrypt ciphertext", libLog.Err(err))

		return nil, err
	}

	// Separating nonce from ciphertext before decrypting
	nonce, cipherText := decodedEncryptedText[:nonceSize], decodedEncryptedText[nonceSize:]

	// #nosec G407: Nonce is randomly generated by the Encrypt method
	// False positive described at https://github.com/securego/gosec/issues/1209
	plainText, err := c.Cipher.Open(nil, nonce, cipherText, nil)
	if err != nil {
		c.logger().Log(context.Background(), libLog.LevelError, "Failed to decrypt ciphertext", libLog.Err(err))
		return nil, err
	}

	result := string(plainText)

	return &result, nil
}
